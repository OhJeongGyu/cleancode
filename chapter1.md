###2017. 2. 15
# 깨끗한 코드 
---
### 코드는 존재하리라
- 코드는 요구사항을 표현하는 언어이다.
- 사람들은 미래에 원하는 기능을 하는 프로그램을 자동으로 생성해주는 기계가 생길 것이라 생각한다.
- 하지만 기계는 정교하고 추상화된 요구사항을 이해할 수 없다. 사람 조차도 다른 사람의 요구사항을 완벽하게 이해할 수 는 없다.
- 요구사항을 정밀하게 표현할 수 있는 방법은 코드를 이용하는 것이다.
- 따라서 미래에도 코드는 존재.

### 나쁜 코드
 - **르블링의 법칙**
  - 대충 짠 프로그램이 돌아가는 것에 안도를 느낌. 나중에 고쳐야지 라고 생각하고 넘어감. 그리고 결코 고치지 않음.
  
### 나쁜 코드로 치르는 대가 
- **나쁜 코드가 쌓이면 더욱 나쁜 코드를 양산한다.**

- ** 원초적 난제** 
 기한이 있어서 쓰레기 코드를 만들어낸다. (x) 
 나쁜 코드를 만들어 내면 기한을 맞출 수 없다. (o)
 기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 것이다. (o)
 
- **깨끗한 코드라는 예술**
 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 아는 것이 아니다. '청결'이라는 힘겹게 습득한 감가을 활용해 자잘한 기법을 적용하는 절제와 규율이 필요하다.
 
- **개발의 대가들이 말하는 깨끗한 코드**

  **비야네 스트롭스트룹**
  > 우아하고 효율적인 코드. 논리가 간단해야 버그가 숨어들지 않는다. 의존성을 줄여야 유지보수가 쉬워진다. 깨끗한 코드는 한 가지를 제대로 처리한다.
  
  **그래디 부치**
  > 깨끗한 코드는 단순하고 직접적이다. 잘 쓴 문장처럼 읽힌다. 설계자의 의도를 숨기지 않는다. 명쾌한 추상화와 단순한 제어문으로 가득하다.
  
  **데이브 토마스**
  > 작성자가 아닌 사람도 읽기쉽고 **고치기 쉽다**. 의미 있는 이름. 의존성은 최소이며 각 의존성을 명확히 정의. API는 명확하며 최소. 
  
  **마이클 페더스**
  > 누군가 **주의 깊게** 짰다는 느낌을 준다. 작성자가 이미 모든 것을 고려해서 짰기 때문에 고칠 곳이 없다.
  
  **론 제프리스**
  > 중복이 없다. 모든 테스트를 통과한다. 클래스, 메서드 함수 등을 최대한 줄인다. 
  
  **워드 커닝햄**
  > 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면~ **아름다운** 코드.
  >> 코드를 읽으면서 놀랄 일이 없어야 한다. **아름다운**?? **코드**가 그 문제를 풀기 위한 언어로 보인다면, **아름다운 코드**라 할 수 있다.
  
- **우리는 저자다**
 우리는 저자다. 다음의 독자는 내가 작성한 코드를 보고 판단 할 것이다. 
 코드를 읽는 시간 대 코드를 짜는 시간의 비율 -> 10:1. 코드를 작성할 때 읽는 비율이 매우 높기 때문에 읽기 쉬운 코드를 만들어 내는 것은 매우 중요하다!
 
- **보이스카우트 규칙**
 잘 짠 코드가 전부가 아니다. 시간이 지나도 여전히 깨끗하게 유지해야 한다.
 > **캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.**
 
- **프리퀄과 원칙**
 클린코드 이후 읽어보길 추천. PPP(소프트웨어 개발의 지혜)
 
- 결론
 예술가의 책을 읽어도 예술가가 되진 않는다. 이 책 또한 마찬가지다. 뛰어난 프로그래머가 생각하는 방식, 사용하는 도구, 방법에 대해서 배울 수 있을 것이다.  